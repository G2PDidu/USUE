# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Артюшин Вадим Борисович
- ОЗИВТ(ППК)-22-2-у

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | - | - |
| Задание 7 | - | - |
| Задание 8 | - | - |
| Задание 9 | - | - |
| Задание 10 | - | - |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи.

```python
from functools import lru_cache


@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    print(fibonacci(100))
```

### Результат.
![Меню](Lab/pic/l1.png)

## Выводы
В данном коде выводятся одна строка с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(fibonacci(100))`: Выводится 354224848179261915075.

## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)

```
### Результат.
![Меню](Lab/pic/l2.png)

## Выводы

В данном коде выводятся три строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Name: {name} Age: {age}")`: Выводится Имена и возраст. 

## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас оповестила о том, что выявлена какая-то ошибка или программа успешно выполнена.

```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат.
![Меню](Lab/pic/l3.png)

## Выводы

В данном коде выводятся одна строка с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(result)`: Выводится результат.


## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводиться “Успешная регистрация”.
```python
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```
### Результат.
![Меню](Lab/pic/l4.png)

## Выводы

В данном коде выводятся две строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Driving the {self.make} {self.model}")`: Выводится NegativeValueException: Длина более 10 символов.

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер, для отслеживания его работы. Готовыми вариантами вы не захотели пользоваться, и поэтому решили создать очень простую пародию. Для этого создали две функции: __init__() (вызывается при создании класса декоратора в программе) и __call__() (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запууском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```
### Результат.
![Меню](Lab/pic/l5.png)

## Выводы

В данном коде выводятся одна строка с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print('> Класс SiteChecker метод __init__ успешный запуск')`: Выводится Класс SiteChecker метод __init__ успешный запуск
2. `print('> Проверка перед запууском', self.func.__name__)`: Выводится Сайт запущен
3. `print('> Проверка безопасного выключения')`: Выводится Проверка перед запууском site
4. `print('Усердная работа сайта')`: Выводится Усердная работа сайта
5. `site()`: Выводится Проверка безопасного выключения
6. `print('>> Сайт выключен')`: Выводится выключен

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"\nФункция {func.__name__} выполнилась за {execution_time:.5f} секунд")
        return result
    return wrapper

@timing_decorator
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```
### Результат.
![Меню](Sam/pic/s1.png)

В данном коде выводятся одна строка с использованием функции `my_CPU`. Каждая строка содержит разные значения:

1. `print(f"\nФункция {func.__name__} выполнилась за {execution_time:.5f} секунд")`: Выводится Функция fibonacci выполнилась за *** секунд.

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            data = file.read()
            if not data:
                raise Exception("Файл пустой")
            else:
                print("Информация из файла:")
                print(data)
    except FileNotFoundError:
        print(f"Файл {file_path} не найден")
    except Exception as e:
        print(f"Ошибка: {e}")


empty_file_path = "empty_file.txt"
open(empty_file_path, 'w').close()

non_empty_file_path = "non_empty_file.txt"
with open(non_empty_file_path, 'w') as file:
    file.write("Hello world.")

print("\nПопытка чтения пустого файла:")
read_file('empty_file.txt')
print("\nПопытка чтения непустого файла:")
read_file('non_empty_file.txt')
```
### Результат.
![Меню](Sam/pic/s2.png)

## Выводы

В данном коде выводятся одна строка с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print("\nПопытка чтения пустого файла:")`: Выводится Попытка чтения пустого файла:.
2. `print(f"Ошибка: {e}")`: Выводится Ошибка: Файл пустой.
3. `print("\nПопытка чтения пустого файла:")`: Выводится Попытка чтения непустого файла:.
4. `print("Информация из файла:")`: Выводится Информация из файла:.
5. `print(data)`: Выводится Hello world.
  
## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
def add_two_and_input():
    try:
        user_input = input("Введите число: ")
        result = 2 + float(user_input)
        print(f"Результат сложения 2 и введенного числа: {result}")
    except ValueError:
        print("Ошибка: Неподходящий тип данных. Ожидалось число.")

add_two_and_input()
add_two_and_input()
add_two_and_input()
```
### Результат.
![Меню](Sam/pic/s3.png)

## Выводы

В данном коде выводятся две строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Результат сложения 2 и введенного числа: {result}")`: Выводится Результат сложения 2 и введенного числа: 3.0.
2. `print(f"Результат сложения 2 и введенного числа: {result}")`: Выводится Результат сложения 2 и введенного числа: 4.0.
3. `print(f"Результат сложения 2 и введенного числа: {result}")`: Выводится Результат сложения 2 и введенного числа: 5.0.
  
## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Декоратор: Вызывается функция {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Декоратор: Функция {func.__name__} выполнена")
        return result
    return wrapper

@my_decorator
def add_numbers(a, b):
    return a + b

@my_decorator
def multiply_numbers(a, b):
    return a * b

result_sum = add_numbers(2, 3)
print(f"Результат сложения: {result_sum}")

result_product = multiply_numbers(4, 5)
print(f"Результат умножения: {result_product}")
```
### Результат.
![Меню](Sam/pic/s4.png)

## Выводы

В данном коде выводятся две строки с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Результат сложения: {result_sum}")`: Выводится Результат сложения: 5.
2. `print(f"Результат умножения: {result_product}")`: Выводится Результат умножения: 20.
  
## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class CustomException(Exception):
    def __init__(self, message="Это мое собственное исключение"):
        self.message = message
        super().__init__(self.message)

def example_function_1(value):
    try:
        if not isinstance(value, int):
            raise CustomException("Ожидалось целое число")
        print(f"Функция получила целое число: {value}")
    except CustomException as ce:
        print(f"Произошло исключение: {ce}")

def example_function_2(value):
    try:
        if value < 0:
            raise CustomException("Ожидалось неотрицательное число")
        print(f"Функция получила неотрицательное число: {value}")
    except CustomException as ce:
        print(f"Произошло исключение: {ce}")

try:
    example_function_1("abc")
except CustomException as ce:
    print(f"Произошло исключение: {ce}")

try:
    example_function_2(-5)
except CustomException as ce:
    print(f"Произошло исключение: {ce}")
```
### Результат.
![Меню](Sam/pic/s5.png)
  
## Выводы

В данном коде выводятся одна строка с использованием функции `print()`. Каждая строка содержит разные значения:

1. `print(f"Произошло исключение: {ce}")`: Выводится Ожидалось целое число.
2. `print(f"Произошло исключение: {ce}")`: Выводится Ожидалось неотрицательное число.


## Общие выводы по теме
Декораторы в Python используются для добавления дополнительного поведения к функциям или методам без изменения их исходного кода. Декоратор - это функция, которая принимает функцию в качестве аргумента и возвращает преобразованную функцию. Декораторы позволяют изменять поведение функции во время выполнения, например, добавить логирование вызовов или проверку аргументов. Исключения в Python используются для обработки ошибок и неожиданных ситуаций во время выполнения программы. Когда возникает ошибка, программа может выдать сообщение об ошибке и завершить работу или же обработать исключение с помощью блока try-except. В Python есть несколько встроенных исключений, таких как IndexError, TypeError и ValueError, которые возникают при определенных условиях. Вы также можете создать свои собственные исключения, если стандартные не подходят для вашей ситуации. 
